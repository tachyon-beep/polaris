# Graph Algorithm Analysis and Improvements

## 1. Shortest Path (Dijkstra's Algorithm)

### Current Implementation Issues
```python
# Current problematic implementation
distances: Dict[str, float] = defaultdict(lambda: float("infinity"))
pq: List[Tuple[float, str]] = [(0, start_node)]
while pq:
    current_distance, current_node = heappop(pq)
    if current_node in visited:
        continue
```

Main problems:
1. No decrease-key operation
2. Allows duplicate nodes in queue
3. No negative cycle detection
4. Inefficient distance tracking

### Improved Implementation
```python
from typing import Dict, Set, Optional, Tuple
from heapq import heappush, heappop
import math

class PriorityQueue:
    def __init__(self):
        self._queue = []  # (priority, counter, item)
        self._index = 0   # Unique sequence for same priorities
        self._entries: Dict[str, Tuple[float, int]] = {}  # Track entries

    def add_or_update(self, item: str, priority: float) -> None:
        if item in self._entries:
            old_priority, old_index = self._entries[item]
            if priority < old_priority:
                # Mark old entry as invalid
                self._entries[item] = (math.inf, old_index)
                # Add new entry
                self._push(item, priority)
        else:
            self._push(item, priority)

    def _push(self, item: str, priority: float) -> None:
        entry = (priority, self._index, item)
        self._entries[item] = (priority, self._index)
        self._index += 1
        heappush(self._queue, entry)

    def pop(self) -> Optional[Tuple[float, str]]:
        while self._queue:
            priority, index, item = heappop(self._queue)
            if self._entries.get(item) == (priority, index):
                del self._entries[item]
                return (priority, item)
        return None

def find_shortest_path(
    graph: Graph, 
    start: str, 
    end: str, 
    weight_func: Optional[Callable[[Edge], float]] = None,
    max_memory_mb: Optional[int] = None,
    allow_negative_weights: bool = False,
    validate_paths: bool = True
) -> PathResult:
    """
    Enhanced shortest path implementation with memory management and validation.
    
    Args:
        graph: Input graph
        start: Starting node ID
        end: Target node ID
        weight_func: Optional function for custom edge weights
        max_memory_mb: Maximum memory usage in MB
        allow_negative_weights: Whether to allow negative edge weights
        validate_paths: Whether to validate paths during search
        
    Returns:
        PathResult containing shortest path and metadata
        
    Raises:
        MemoryLimitExceeded: If memory usage exceeds max_memory_mb
        NegativeWeightError: If negative weights detected when not allowed
        ValidationError: If path validation fails
    """
    # Memory monitoring
    memory_usage = 0
    def check_memory():
        nonlocal memory_usage
        if max_memory_mb:
            current_mem = get_memory_usage()  # Implementation needed
            if current_mem > max_memory_mb * 1024 * 1024:
                raise MemoryLimitExceeded(
                    f"Memory usage {current_mem/1024/1024:.1f}MB exceeds "
                    f"limit of {max_memory_mb}MB"
                )
    
    # Handle negative weights
    if allow_negative_weights:
        has_negative = any(
            weight_func(e) < 0 if weight_func else e.weight < 0 
            for e in graph.get_edges()
        )
        if has_negative:
            return find_bellman_ford_path(
                graph, start, end, weight_func, max_memory_mb
            )
            
    # Initialize data structures
    distances: Dict[str, float] = {start: 0.0}
    predecessors: Dict[str, Optional[str]] = {start: None}
    pq = PriorityQueue()
    pq.add_or_update(start, 0.0)
    
    # Main loop
    while not pq.empty():
        check_memory()
        current_dist, current_node = pq.pop()
        
        # Found target
        if current_node == end:
            path = reconstruct_path(predecessors, end)
            if validate_paths:
                validate_path_consistency(path, graph)
            return create_path_result(path, weight_func)
            
        # Process neighbors
        for neighbor in graph.get_neighbors(current_node):
            edge = graph.get_edge(current_node, neighbor)
            if not edge:
                continue
                
            edge_weight = weight_func(edge) if weight_func else edge.weight
            if not allow_negative_weights and edge_weight < 0:
                raise NegativeWeightError(
                    f"Negative weight {edge_weight} detected on edge "
                    f"{current_node} -> {neighbor}"
                )
                
            new_distance = distances[current_node] + edge_weight
            
            if neighbor not in distances or new_distance < distances[neighbor]:
                distances[neighbor] = new_distance
                predecessors[neighbor] = current_node
                pq.add_or_update(neighbor, new_distance)
                
    raise NoPathError(f"No path exists between {start} and {end}")

```

### Additional Improvements:
1. Add A* variant for heuristic-guided search
2. Add bidirectional Dijkstra's
3. Add support for path constraints

## 2. All Paths Algorithm

### Current Implementation Issues
```python
# Current problematic implementation
stack: List[Tuple[str, List[Edge], Set[str], float]] = [
    (start_node, [], {start_node}, 0.0)
]
while stack and paths_found < max_paths:
    current, path_edges, visited, total_weight = stack.pop()
```

Problems:
1. Memory inefficient
2. No early pruning
3. No path optimization

### Improved Implementation
```python
from collections import deque
from dataclasses import dataclass
from typing import Generator, Set, List, Optional

@dataclass(frozen=True)
class PathState:
    """
    Memory-efficient immutable path state.
    
    Uses __slots__ for memory optimization and implements custom hash
    function for better performance in sets/dicts.
    """
    __slots__ = ('node', 'prev_edge', 'prev_state', 'depth', 'total_weight')
    
    node: str
    prev_edge: Optional[Edge]
    prev_state: Optional['PathState']
    depth: int
    total_weight: float
    
    def __hash__(self) -> int:
        # Custom hash combining node and state chain
        hash_val = hash(self.node)
        if self.prev_state:
            hash_val ^= id(self.prev_state) 
        return hash_val
    
    def __eq__(self, other: object) -> bool:
        if not isinstance(other, PathState):
            return NotImplemented
        return (
            self.node == other.node and
            self.prev_edge == other.prev_edge and
            self.prev_state is other.prev_state and
            self.depth == other.depth and
            abs(self.total_weight - other.total_weight) < 1e-9
        )
        
    def get_path(self) -> List[Edge]:
        """Efficiently reconstruct path from state chain."""
        path = []
        current = self
        # Preallocate list for better performance
        while current.prev_edge:
            path.append(current.prev_edge)
            current = current.prev_state
            if not current:
                break
        path.reverse()
        return path
        
    def get_visited(self) -> Set[str]:
        """Efficiently get set of visited nodes."""
        visited = set()
        current = self
        while current:
            visited.add(current.node)
            current = current.prev_state
        return visited
        
    @property
    def memory_size(self) -> int:
        """Estimate memory usage in bytes."""
        base_size = (
            len(self.node) +  # string storage
            8 +  # depth (int)
            8 +  # total_weight (float)
            24   # object overhead
        )
        # Add edge size if present
        if self.prev_edge:
            base_size += 64  # Approximate Edge object size
        return base_size

class AllPathsFinder:
    def __init__(self, graph: Graph):
        self.graph = graph
        self.path_cache = {}  # Cache common subpaths
        
    def find_all_paths(
        self,
        start: str,
        end: str,
        max_length: Optional[int] = None,
        max_paths: Optional[int] = None,
        filter_func = None,
        weight_func = None
    ) -> Generator[PathResult, None, None]:
        """
        Improved all-paths implementation with memory efficiency and pruning.
        """
        if not self.graph.has_node(start) or not self.graph.has_node(end):
            return
            
        # Use deque for BFS-like exploration
        queue = deque([PathState(start, None, None, 0, 0.0)])
        paths_found = 0
        
        # Track path statistics for pruning
        min_path_weight = float('inf')
        
        while queue and (max_paths is None or paths_found < max_paths):
            current_state = queue.popleft()
            
            # Early pruning conditions
            if max_length and current_state.depth >= max_length:
                continue
                
            if current_state.total_weight > min_path_weight * 2:
                continue  # Prune paths that are too expensive
                
            # Check if we reached target
            if current_state.node == end:
                path = current_state.get_path()
                
                # Apply filter if provided
                if filter_func and not filter_func(path):
                    continue
                    
                # Update statistics
                min_path_weight = min(min_path_weight, current_state.total_weight)
                
                # Yield result
                yield create_path_result(path, weight_func)
                paths_found += 1
                continue
                
            # Get visited nodes for cycle detection
            visited = current_state.get_visited()
            
            # Process neighbors
            neighbors = sorted(
                self.graph.get_neighbors(current_state.node),
                key=lambda x: self._estimate_cost(x, end)
            )
            
            for neighbor in neighbors:
                if neighbor in visited:
                    continue
                    
                edge = self.graph.get_edge(current_state.node, neighbor)
                if not edge:
                    continue
                    
                edge_weight = get_edge_weight(edge, weight_func)
                new_weight = current_state.total_weight + edge_weight
                
                # Pruning check
                if new_weight > min_path_weight * 2:
                    continue
                    
                new_state = PathState(
                    node=neighbor,
                    prev_edge=edge,
                    prev_state=current_state,
                    depth=current_state.depth + 1,
                    total_weight=new_weight
                )
                
                queue.append(new_state)
                
    def _estimate_cost(self, node: str, target: str) -> float:
        """Heuristic function for neighbor ordering."""
        # Could be improved with domain-specific knowledge
        return 0.0
```

### Additional Improvements:
1. Add Yen's K-shortest paths algorithm
2. Add parallel path finding support
3. Add path diversity metrics

## 3. Bidirectional Search

### Current Implementation Issues
```python
# Current problematic implementation
def _expand_search(self, current: SearchState, opposite: SearchState, ...):
    if not current.queue:
        return None
    node, depth, total_weight = current.queue.popleft()
```

Problems:
1. Inefficient intersection detection
2. Poor expansion strategy
3. No proper termination condition

### Improved Implementation
```python
from dataclasses import dataclass
from typing import Dict, Set, Optional, Tuple
from heapq import heappush, heappop

@dataclass(frozen=True)
class SearchFrontier:
    """Immutable search frontier state."""
    distances: Dict[str, float]
    predecessors: Dict[str, Tuple[str, Edge]]
    queue: List[Tuple[float, str]]
    visited: Set[str]

class BidirectionalSearch:
    def __init__(self, graph: Graph):
        self.graph = graph
        
    def find_path(
        self,
        start: str,
        end: str,
        weight_func = None,
        max_length: Optional[int] = None
    ) -> PathResult:
        """
        Improved bidirectional search with proper termination conditions.
        """
        # Initialize frontiers
        forward = self._init_frontier(start)
        backward = self._init_frontier(end)
        
        # Track best path
        best_path = None
        best_weight = float('inf')
        meeting_node = None
        
        # Balance parameters
        mu = 1.0  # Controls expansion balance
        
        while forward.queue and backward.queue:
            # Get minimum distances at frontiers
            min_forward = forward.queue[0][0]
            min_backward = backward.queue[0][0]
            
            # Termination condition
            if min_forward + min_backward >= best_weight:
                break
                
            # Expand forward or backward based on balance
            if min_forward <= mu * min_backward:
                meeting_node = self._expand(
                    forward, backward, weight_func, max_length, True)
            else:
                meeting_node = self._expand(
                    backward, forward, weight_func, max_length, False)
                
            # Update best path if intersection found
            if meeting_node:
                path_weight = (forward.distances.get(meeting_node, float('inf')) +
                             backward.distances.get(meeting_node, float('inf')))
                             
                if path_weight < best_weight:
                    best_weight = path_weight
                    best_path = self._reconstruct_path(
                        meeting_node, forward, backward)
                        
        if not best_path:
            raise NoPathError(f"No path exists between {start} and {end}")
            
        return create_path_result(best_path, weight_func)
        
    def _expand(
        self,
        current: SearchFrontier,
        opposite: SearchFrontier,
        weight_func,
        max_length: Optional[int],
        is_forward: bool
    ) -> Optional[str]:
        """Expand one frontier and check for intersections."""
        if not current.queue:
            return None
            
        current_dist, current_node = heappop(current.queue)
        
        # Skip if we've found a better path
        if current_node in current.visited:
            return None
            
        current.visited.add(current_node)
        
        # Check for intersection
        if current_node in opposite.visited:
            return current_node
            
        # Process neighbors
        neighbors = self.graph.get_neighbors(current_node, reverse=not is_forward)
        for neighbor in neighbors:
            if neighbor in current.visited:
                continue
                
            edge = self.graph.get_edge(
                current_node if is_forward else neighbor,
                neighbor if is_forward else current_node
            )
            if not edge:
                continue
                
            edge_weight = get_edge_weight(edge, weight_func)
            new_distance = current_dist + edge_weight
            
            if (neighbor not in current.distances or 
                new_distance < current.distances[neighbor]):
                current.distances[neighbor] = new_distance
                current.predecessors[neighbor] = (current_node, edge)
                heappush(current.queue, (new_distance, neighbor))
                
        return None
        
    def _reconstruct_path(
        self,
        meeting_node: str,
        forward: SearchFrontier,
        backward: SearchFrontier
    ) -> List[Edge]:
        """Reconstruct path from meeting point."""
        path = []
        
        # Build forward path
        current = meeting_node
        while current in forward.predecessors:
            prev, edge = forward.predecessors[current]
            path.append(edge)
            current = prev
        path.reverse()
        
        # Build backward path
        current = meeting_node
        while current in backward.predecessors:
            next_node, edge = backward.predecessors[current]
            path.append(edge)
            current = next_node
            
        return path
```

### Additional Improvements:
1. Add contraction hierarchies
2. Add reach-based pruning
3. Add goal-directed search

## Suggested Additional Algorithms

1. **Contraction Hierarchies**
   - Pre-processing based speedup technique
   - Excellent for static graphs
   - Supports fast distance queries

2. **A* with Landmarks (ALT)**
   - Uses triangle inequality for better heuristics
   - Good for dynamic graphs
   - Better than basic A* for sparse graphs

3. **Hub Labeling**
   - Fast distance queries
   - Good for dense graphs
   - High preprocessing cost but very fast queries

4. **Transit Node Routing**
   - Excellent for road networks
   - Uses access nodes concept
   - Very fast for long-distance queries

# Advanced Graph Algorithm Implementations

## 1. Contraction Hierarchies

Contraction Hierarchies provide massive speedup for shortest path queries by preprocessing the graph.

```python
from dataclasses import dataclass
from typing import Dict, Set, List, Tuple, Optional
from heapq import heappush, heappop

@dataclass(frozen=True)
class Shortcut:
    edge: Edge
    via_node: str
    lower_edge: Edge
    upper_edge: Edge

class ContractionHierarchies:
    def __init__(self, graph: Graph):
        self.graph = graph
        self.node_level: Dict[str, int] = {}
        self.shortcuts: Dict[Tuple[str, str], Shortcut] = {}
        self.contracted_neighbors: Dict[str, Set[str]] = defaultdict(set)
        
    def preprocess(self) -> None:
        """Preprocess graph to build contraction hierarchy."""
        # Calculate initial node ordering
        node_importance = self._calculate_node_importance()
        pq = [(importance, node) for node, importance in node_importance.items()]
        heapq.heapify(pq)
        
        level = 0
        while pq:
            _, node = heappop(pq)
            if node not in self.node_level:  # Not yet contracted
                # Contract node
                shortcuts = self._contract_node(node)
                self.node_level[node] = level
                level += 1
                
                # Update importance of affected nodes
                affected = set()
                for u, v in shortcuts:
                    affected.add(u)
                    affected.add(v)
                    
                for affected_node in affected:
                    if affected_node not in self.node_level:
                        new_importance = self._calculate_node_importance(affected_node)
                        heappush(pq, (new_importance, affected_node))
                        
    def _contract_node(self, node: str) -> List[Tuple[str, str]]:
        """Contract a node and add necessary shortcuts."""
        shortcuts = []
        incoming = self.graph.get_neighbors(node, reverse=True)
        outgoing = self.graph.get_neighbors(node)
        
        for u in incoming:
            if u in self.node_level:  # Skip already contracted nodes
                continue
                
            for v in outgoing:
                if v in self.node_level or u == v:
                    continue
                    
                # Check if shortcut is necessary
                lower_edge = self.graph.get_edge(u, node)
                upper_edge = self.graph.get_edge(node, v)
                if not lower_edge or not upper_edge:
                    continue
                    
                shortcut_weight = (get_edge_weight(lower_edge) + 
                                 get_edge_weight(upper_edge))
                                 
                # Check if shortcut is necessary (witness search)
                if self._is_shortcut_necessary(u, v, node, shortcut_weight):
                    shortcut_edge = Edge(
                        from_entity=u,
                        to_entity=v,
                        relation_type=RelationType.SHORTCUT,
                        metadata=EdgeMetadata(
                            weight=shortcut_weight,
                            via_node=node
                        )
                    )
                    
                    self.shortcuts[(u, v)] = Shortcut(
                        edge=shortcut_edge,
                        via_node=node,
                        lower_edge=lower_edge,
                        upper_edge=upper_edge
                    )
                    
                    shortcuts.append((u, v))
                    self.contracted_neighbors[u].add(v)
                    
        return shortcuts
        
    def _is_shortcut_necessary(
        self, 
        u: str, 
        v: str, 
        via: str, 
        shortcut_weight: float
    ) -> bool:
        """Determine if shortcut is necessary using witness search."""
        MAX_WITNESS_SEARCH_STEPS = 50  # Limit witness search
        
        distances = {u: 0.0}
        pq = [(0.0, u)]
        visited = set()
        steps = 0
        
        while pq and steps < MAX_WITNESS_SEARCH_STEPS:
            dist, node = heappop(pq)
            
            if node == v:
                return dist >= shortcut_weight
                
            if node in visited:
                continue
                
            visited.add(node)
            steps += 1
            
            for neighbor in self.graph.get_neighbors(node):
                if neighbor == via:  # Don't go through the node being contracted
                    continue
                    
                edge = self.graph.get_edge(node, neighbor)
                if not edge:
                    continue
                    
                new_dist = dist + get_edge_weight(edge)
                if new_dist < shortcut_weight:  # Early termination
                    if neighbor not in distances or new_dist < distances[neighbor]:
                        distances[neighbor] = new_dist
                        heappush(pq, (new_dist, neighbor))
                        
        return True  # No witness path found
        
    def _calculate_node_importance(self, node: str) -> float:
        """Calculate importance of a node for contraction ordering."""
        edge_difference = self._count_shortcuts(node) - len(list(self.graph.get_neighbors(node)))
        contracted_neighbors = len(self.contracted_neighbors[node])
        level = self.node_level.get(node, 0)
        
        # Combine factors with appropriate weights
        return (
            5 * edge_difference +
            3 * contracted_neighbors +
            2 * level
        )
        
    def _count_shortcuts(self, node: str) -> int:
        """Count number of shortcuts needed when contracting node."""
        shortcuts = set()
        incoming = self.graph.get_neighbors(node, reverse=True)
        outgoing = self.graph.get_neighbors(node)
        
        for u in incoming:
            if u in self.node_level:
                continue
            for v in outgoing:
                if v in self.node_level or u == v:
                    continue
                shortcuts.add((u, v))
                
        return len(shortcuts)

```

## 2. A* with Landmarks (ALT Algorithm)

The ALT algorithm uses triangle inequality with precomputed landmarks to provide better heuristics for A* search.

```python
from typing import Dict, Set, List, Optional
import numpy as np

class ALTPathFinder:
    def __init__(self, graph: Graph, num_landmarks: int = 16):
        self.graph = graph
        self.landmarks: List[str] = self._select_landmarks(num_landmarks)
        self.distances: Dict[str, Dict[str, float]] = {}
        self._precompute_distances()
        
    def _select_landmarks(self, num_landmarks: int) -> List[str]:
        """Select landmarks using maximal separation method."""
        nodes = list(self.graph.get_nodes())
        if len(nodes) <= num_landmarks:
            return nodes
            
        landmarks = []
        # Start with a random node
        landmarks.append(random.choice(nodes))
        
        while len(landmarks) < num_landmarks:
            max_distance = -1
            next_landmark = None
            
            # For each node, compute minimum distance to existing landmarks
            for node in nodes:
                if node in landmarks:
                    continue
                    
                min_dist = float('inf')
                for landmark in landmarks:
                    dist = self._compute_distance(node, landmark)
                    min_dist = min(min_dist, dist)
                    
                if min_dist > max_distance:
                    max_distance = min_dist
                    next_landmark = node
                    
            if next_landmark:
                landmarks.append(next_landmark)
                
        return landmarks
        
    def _precompute_distances(self) -> None:
        """Precompute distances from all nodes to landmarks."""
        for landmark in self.landmarks:
            # Forward distances
            forward_distances = self._dijkstra_from_landmark(landmark)
            self.distances[landmark] = forward_distances
            
            # Backward distances
            backward_distances = self._dijkstra_to_landmark(landmark)
            self.distances[f"r_{landmark}"] = backward_distances
            
    def _compute_heuristic(self, node: str, target: str) -> float:
        """Compute ALT heuristic using landmarks."""
        h = 0.0
        for landmark in self.landmarks:
            # Forward heuristic
            if (landmark in self.distances and 
                node in self.distances[landmark] and 
                target in self.distances[landmark]):
                h = max(h, abs(
                    self.distances[landmark][target] - 
                    self.distances[landmark][node]
                ))
            
            # Backward heuristic
            r_landmark = f"r_{landmark}"
            if (r_landmark in self.distances and 
                node in self.distances[r_landmark] and 
                target in self.distances[r_landmark]):
                h = max(h, abs(
                    self.distances[r_landmark][node] - 
                    self.distances[r_landmark][target]
                ))
                
        return h
        
    def find_path(
        self,
        start: str,
        end: str,
        weight_func = None
    ) -> PathResult:
        """Find shortest path using A* with ALT heuristic."""
        pq = [(0.0, 0.0, start)]  # (f_score, g_score, node)
        g_scores = {start: 0.0}
        came_from = {}
        
        while pq:
            f_score, g_score, current = heappop(pq)
            
            if current == end:
                return self._reconstruct_path(came_from, end)
                
            for neighbor in self.graph.get_neighbors(current):
                edge = self.graph.get_edge(current, neighbor)
                if not edge:
                    continue
                    
                tentative_g = g_score + get_edge_weight(edge, weight_func)
                
                if (neighbor not in g_scores or 
                    tentative_g < g_scores[neighbor]):
                    came_from[neighbor] = (current, edge)
                    g_scores[neighbor] = tentative_g
                    h_score = self._compute_heuristic(neighbor, end)
                    f_score = tentative_g + h_score
                    heappush(pq, (f_score, tentative_g, neighbor))
                    
        raise NoPathError(f"No path exists between {start} and {end}")
```

## 3. Hub Labeling

Hub Labeling provides extremely fast distance queries at the cost of higher preprocessing time and space.

```python
from typing import Dict, Set, List, Tuple
import numpy as np

class HubLabels:
    def __init__(self, graph: Graph):
        self.graph = graph
        self.forward_labels: Dict[str, List[Tuple[str, float]]] = {}
        self.backward_labels: Dict[str, List[Tuple[str, float]]] = {}
        
    def preprocess(self) -> None:
        """Preprocess graph to compute hub labels."""
        # Compute node ordering (can use various strategies)
        node_order = self._compute_node_order()
        
        # Process nodes in order
        for node in node_order:
            # Compute forward labels
            self._compute_forward_labels(node)
            # Compute backward labels
            self._compute_backward_labels(node)
            
    def _compute_forward_labels(self, node: str) -> None:
        """Compute forward labels for a node using pruned Dijkstra."""
        distances = {node: 0.0}
        pq = [(0.0, node)]
        
        while pq:
            dist, current = heappop(pq)
            
            # Pruning condition
            if self._should_prune_forward(node, current, dist):
                continue
                
            # Add label
            if node not in self.forward_labels:
                self.forward_labels[node] = []
            self.forward_labels[node].append((current, dist))
            
            # Explore neighbors
            for neighbor in self.graph.get_neighbors(current):
                edge = self.graph.get_edge(current, neighbor)
                if not edge:
                    continue
                    
                new_dist = dist + get_edge_weight(edge)
                if (neighbor not in distances or 
                    new_dist < distances[neighbor]):
                    distances[neighbor] = new_dist
                    heappush(pq, (new_dist, neighbor))
                    
    def _should_prune_forward(
        self,
        source: str,
        current: str,
        distance: float
    ) -> bool:
        """Check if forward search can be pruned."""
        if current not in self.forward_labels:
            return False
            
        # Check if distance can be computed using existing labels
        min_dist = float('inf')
        for hub, hub_dist in self.forward_labels[source]:
            if hub in self.backward_labels:
                for target, target_dist in self.backward_labels[hub]:
                    if target == current:
                        min_dist = min(min_dist, hub_dist + target_dist)
                        
        return distance >= min_dist
        
    def query_distance(self, source: str, target: str) -> float:
        """Query shortest path distance using hub labels."""
        if source not in self.forward_labels or target not in self.backward_labels:
            raise NoPathError(f"No path exists between {source} and {target}")
            
        min_dist = float('inf')
        for hub, forward_dist in self.forward_labels[source]:
            if hub in self.backward_labels[target]:
                backward_dist = next(
                    d for h, d in self.backward_labels[target] if h == hub
                )
                min_dist = min(min_dist, forward_dist + backward_dist)
                
        if min_dist == float('inf'):
            raise NoPathError(f"No path exists between {source} and {target}")
            
        return min_dist
```

## 4. Transit Node Routing

Specialized for road networks, Transit Node Routing provides extremely fast queries for long-distance routes.

```python
from typing import Dict, Set, List, Tuple
import numpy as np

class TransitNodeRouting:
    def __init__(self, graph: Graph):
        self.graph = graph
        self.transit_nodes: Set[str] = set()
        self.access_nodes: Dict[str, Set[str]] = {}
        self.distances: Dict[Tuple[str, str], float] = {}
        
    def preprocess(self, num_transit_nodes: int = 1000) -> None:
        """Preprocess graph to identify transit nodes and compute distances."""
        # Select transit nodes (could use various strategies)
        self.transit_nodes = self._select_transit_nodes(num_transit_nodes)
        
        # Compute access nodes for each vertex
        for node in self.graph.get_nodes():
            self.access_nodes[node] = self._compute_access_nodes(node)
            
        # Compute distances between transit nodes
        self._compute_transit_distances()
        
    def _select_transit_nodes(self, num_nodes: int) -> Set[str]:
        """Select transit nodes using degree centrality."""
        nodes = [(node, len(list(self.graph.get_neighbors(node))))
                for node in self.graph.get_nodes()]
        nodes.sort(key=lambda x: x[1], reverse=True)
        return set
    
    # Advanced Graph Algorithm Implementations

## 1. Contraction Hierarchies

Contraction Hierarchies provide massive speedup for shortest path queries by preprocessing the graph.

```python
from dataclasses import dataclass
from typing import Dict, Set, List, Tuple, Optional
from heapq import heappush, heappop

@dataclass(frozen=True)
class Shortcut:
    edge: Edge
    via_node: str
    lower_edge: Edge
    upper_edge: Edge

class ContractionHierarchies:
    def __init__(self, graph: Graph):
        self.graph = graph
        self.node_level: Dict[str, int] = {}
        self.shortcuts: Dict[Tuple[str, str], Shortcut] = {}
        self.contracted_neighbors: Dict[str, Set[str]] = defaultdict(set)
        
    def preprocess(self) -> None:
        """Preprocess graph to build contraction hierarchy."""
        # Calculate initial node ordering
        node_importance = self._calculate_node_importance()
        pq = [(importance, node) for node, importance in node_importance.items()]
        heapq.heapify(pq)
        
        level = 0
        while pq:
            _, node = heappop(pq)
            if node not in self.node_level:  # Not yet contracted
                # Contract node
                shortcuts = self._contract_node(node)
                self.node_level[node] = level
                level += 1
                
                # Update importance of affected nodes
                affected = set()
                for u, v in shortcuts:
                    affected.add(u)
                    affected.add(v)
                    
                for affected_node in affected:
                    if affected_node not in self.node_level:
                        new_importance = self._calculate_node_importance(affected_node)
                        heappush(pq, (new_importance, affected_node))
                        
    def _contract_node(self, node: str) -> List[Tuple[str, str]]:
        """Contract a node and add necessary shortcuts."""
        shortcuts = []
        incoming = self.graph.get_neighbors(node, reverse=True)
        outgoing = self.graph.get_neighbors(node)
        
        for u in incoming:
            if u in self.node_level:  # Skip already contracted nodes
                continue
                
            for v in outgoing:
                if v in self.node_level or u == v:
                    continue
                    
                # Check if shortcut is necessary
                lower_edge = self.graph.get_edge(u, node)
                upper_edge = self.graph.get_edge(node, v)
                if not lower_edge or not upper_edge:
                    continue
                    
                shortcut_weight = (get_edge_weight(lower_edge) + 
                                 get_edge_weight(upper_edge))
                                 
                # Check if shortcut is necessary (witness search)
                if self._is_shortcut_necessary(u, v, node, shortcut_weight):
                    shortcut_edge = Edge(
                        from_entity=u,
                        to_entity=v,
                        relation_type=RelationType.SHORTCUT,
                        metadata=EdgeMetadata(
                            weight=shortcut_weight,
                            via_node=node
                        )
                    )
                    
                    self.shortcuts[(u, v)] = Shortcut(
                        edge=shortcut_edge,
                        via_node=node,
                        lower_edge=lower_edge,
                        upper_edge=upper_edge
                    )
                    
                    shortcuts.append((u, v))
                    self.contracted_neighbors[u].add(v)
                    
        return shortcuts
        
    def _is_shortcut_necessary(
        self, 
        u: str, 
        v: str, 
        via: str, 
        shortcut_weight: float
    ) -> bool:
        """Determine if shortcut is necessary using witness search."""
        MAX_WITNESS_SEARCH_STEPS = 50  # Limit witness search
        
        distances = {u: 0.0}
        pq = [(0.0, u)]
        visited = set()
        steps = 0
        
        while pq and steps < MAX_WITNESS_SEARCH_STEPS:
            dist, node = heappop(pq)
            
            if node == v:
                return dist >= shortcut_weight
                
            if node in visited:
                continue
                
            visited.add(node)
            steps += 1
            
            for neighbor in self.graph.get_neighbors(node):
                if neighbor == via:  # Don't go through the node being contracted
                    continue
                    
                edge = self.graph.get_edge(node, neighbor)
                if not edge:
                    continue
                    
                new_dist = dist + get_edge_weight(edge)
                if new_dist < shortcut_weight:  # Early termination
                    if neighbor not in distances or new_dist < distances[neighbor]:
                        distances[neighbor] = new_dist
                        heappush(pq, (new_dist, neighbor))
                        
        return True  # No witness path found
        
    def _calculate_node_importance(self, node: str) -> float:
        """Calculate importance of a node for contraction ordering."""
        edge_difference = self._count_shortcuts(node) - len(list(self.graph.get_neighbors(node)))
        contracted_neighbors = len(self.contracted_neighbors[node])
        level = self.node_level.get(node, 0)
        
        # Combine factors with appropriate weights
        return (
            5 * edge_difference +
            3 * contracted_neighbors +
            2 * level
        )
        
    def _count_shortcuts(self, node: str) -> int:
        """Count number of shortcuts needed when contracting node."""
        shortcuts = set()
        incoming = self.graph.get_neighbors(node, reverse=True)
        outgoing = self.graph.get_neighbors(node)
        
        for u in incoming:
            if u in self.node_level:
                continue
            for v in outgoing:
                if v in self.node_level or u == v:
                    continue
                shortcuts.add((u, v))
                
        return len(shortcuts)

```

## 2. A* with Landmarks (ALT Algorithm)

The ALT algorithm uses triangle inequality with precomputed landmarks to provide better heuristics for A* search.

```python
from typing import Dict, Set, List, Optional
import numpy as np

class ALTPathFinder:
    def __init__(self, graph: Graph, num_landmarks: int = 16):
        self.graph = graph
        self.landmarks: List[str] = self._select_landmarks(num_landmarks)
        self.distances: Dict[str, Dict[str, float]] = {}
        self._precompute_distances()
        
    def _select_landmarks(self, num_landmarks: int) -> List[str]:
        """Select landmarks using maximal separation method."""
        nodes = list(self.graph.get_nodes())
        if len(nodes) <= num_landmarks:
            return nodes
            
        landmarks = []
        # Start with a random node
        landmarks.append(random.choice(nodes))
        
        while len(landmarks) < num_landmarks:
            max_distance = -1
            next_landmark = None
            
            # For each node, compute minimum distance to existing landmarks
            for node in nodes:
                if node in landmarks:
                    continue
                    
                min_dist = float('inf')
                for landmark in landmarks:
                    dist = self._compute_distance(node, landmark)
                    min_dist = min(min_dist, dist)
                    
                if min_dist > max_distance:
                    max_distance = min_dist
                    next_landmark = node
                    
            if next_landmark:
                landmarks.append(next_landmark)
                
        return landmarks
        
    def _precompute_distances(self) -> None:
        """Precompute distances from all nodes to landmarks."""
        for landmark in self.landmarks:
            # Forward distances
            forward_distances = self._dijkstra_from_landmark(landmark)
            self.distances[landmark] = forward_distances
            
            # Backward distances
            backward_distances = self._dijkstra_to_landmark(landmark)
            self.distances[f"r_{landmark}"] = backward_distances
            
    def _compute_heuristic(self, node: str, target: str) -> float:
        """Compute ALT heuristic using landmarks."""
        h = 0.0
        for landmark in self.landmarks:
            # Forward heuristic
            if (landmark in self.distances and 
                node in self.distances[landmark] and 
                target in self.distances[landmark]):
                h = max(h, abs(
                    self.distances[landmark][target] - 
                    self.distances[landmark][node]
                ))
            
            # Backward heuristic
            r_landmark = f"r_{landmark}"
            if (r_landmark in self.distances and 
                node in self.distances[r_landmark] and 
                target in self.distances[r_landmark]):
                h = max(h, abs(
                    self.distances[r_landmark][node] - 
                    self.distances[r_landmark][target]
                ))
                
        return h
        
    def find_path(
        self,
        start: str,
        end: str,
        weight_func = None
    ) -> PathResult:
        """Find shortest path using A* with ALT heuristic."""
        pq = [(0.0, 0.0, start)]  # (f_score, g_score, node)
        g_scores = {start: 0.0}
        came_from = {}
        
        while pq:
            f_score, g_score, current = heappop(pq)
            
            if current == end:
                return self._reconstruct_path(came_from, end)
                
            for neighbor in self.graph.get_neighbors(current):
                edge = self.graph.get_edge(current, neighbor)
                if not edge:
                    continue
                    
                tentative_g = g_score + get_edge_weight(edge, weight_func)
                
                if (neighbor not in g_scores or 
                    tentative_g < g_scores[neighbor]):
                    came_from[neighbor] = (current, edge)
                    g_scores[neighbor] = tentative_g
                    h_score = self._compute_heuristic(neighbor, end)
                    f_score = tentative_g + h_score
                    heappush(pq, (f_score, tentative_g, neighbor))
                    
        raise NoPathError(f"No path exists between {start} and {end}")
```

## 3. Hub Labeling

Hub Labeling provides extremely fast distance queries at the cost of higher preprocessing time and space.

```python
from typing import Dict, Set, List, Tuple
import numpy as np

class HubLabels:
    def __init__(self, graph: Graph):
        self.graph = graph
        self.forward_labels: Dict[str, List[Tuple[str, float]]] = {}
        self.backward_labels: Dict[str, List[Tuple[str, float]]] = {}
        
    def preprocess(self) -> None:
        """Preprocess graph to compute hub labels."""
        # Compute node ordering (can use various strategies)
        node_order = self._compute_node_order()
        
        # Process nodes in order
        for node in node_order:
            # Compute forward labels
            self._compute_forward_labels(node)
            # Compute backward labels
            self._compute_backward_labels(node)
            
    def _compute_forward_labels(self, node: str) -> None:
        """Compute forward labels for a node using pruned Dijkstra."""
        distances = {node: 0.0}
        pq = [(0.0, node)]
        
        while pq:
            dist, current = heappop(pq)
            
            # Pruning condition
            if self._should_prune_forward(node, current, dist):
                continue
                
            # Add label
            if node not in self.forward_labels:
                self.forward_labels[node] = []
            self.forward_labels[node].append((current, dist))
            
            # Explore neighbors
            for neighbor in self.graph.get_neighbors(current):
                edge = self.graph.get_edge(current, neighbor)
                if not edge:
                    continue
                    
                new_dist = dist + get_edge_weight(edge)
                if (neighbor not in distances or 
                    new_dist < distances[neighbor]):
                    distances[neighbor] = new_dist
                    heappush(pq, (new_dist, neighbor))
                    
    def _should_prune_forward(
        self,
        source: str,
        current: str,
        distance: float
    ) -> bool:
        """Check if forward search can be pruned."""
        if current not in self.forward_labels:
            return False
            
        # Check if distance can be computed using existing labels
        min_dist = float('inf')
        for hub, hub_dist in self.forward_labels[source]:
            if hub in self.backward_labels:
                for target, target_dist in self.backward_labels[hub]:
                    if target == current:
                        min_dist = min(min_dist, hub_dist + target_dist)
                        
        return distance >= min_dist
        
    def query_distance(self, source: str, target: str) -> float:
        """Query shortest path distance using hub labels."""
        if source not in self.forward_labels or target not in self.backward_labels:
            raise NoPathError(f"No path exists between {source} and {target}")
            
        min_dist = float('inf')
        for hub, forward_dist in self.forward_labels[source]:
            if hub in self.backward_labels[target]:
                backward_dist = next(
                    d for h, d in self.backward_labels[target] if h == hub
                )
                min_dist = min(min_dist, forward_dist + backward_dist)
                
        if min_dist == float('inf'):
            raise NoPathError(f"No path exists between {source} and {target}")
            
        return min_dist
```

## 4. Transit Node Routing

Specialized for road networks, Transit Node Routing provides extremely fast queries for long-distance routes.

```python
from typing import Dict, Set, List, Tuple
import numpy as np

class TransitNodeRouting:
    def __init__(self, graph: Graph):
        self.graph = graph
        self.transit_nodes: Set[str] = set()
        self.access_nodes: Dict[str, Set[str]] = {}
        self.distances: Dict[Tuple[str, str], float] = {}
        
    def preprocess(self, num_transit_nodes: int = 1000) -> None:
        """Preprocess graph to identify transit nodes and compute distances."""
        # Select transit nodes (could use various strategies)
        self.transit_nodes = self._select_transit_nodes(num_transit_nodes)
        
        # Compute access nodes for each vertex
        for node in self.graph.get_nodes():
            self.access_nodes[node] = self._compute_access_nodes(node)
            
        # Compute distances between transit nodes
        self._compute_transit_distances()
        
    def _select_transit_nodes(self, num_nodes: int) -> Set[str]:
        """Select transit nodes using degree centrality."""
        nodes = [(node, len(list(self.graph.get_neighbors(node))))
                for node in self.graph.get_nodes()]
        nodes.sort(key=lambda x: x[1], reverse=True)
        return set(node for node, _ in nodes[:num_nodes])
        
    def _compute_access_nodes(self, node: str) -> Set[str]:
        """Compute access nodes for a given vertex."""
        access_nodes = set()
        distance_threshold = self._compute_distance_threshold(node)
        
        # Run Dijkstra until threshold
        distances = {node: 0.0}
        pq = [(0.0, node)]
        
        while pq:
            dist, current = heappop(pq)
            
            if dist > distance_threshold:
                break
                
            if current in self.transit_nodes:
                access_nodes.add(current)
                continue
                
            for neighbor in self.graph.get_neighbors(current):
                edge = self.graph.get_edge(current, neighbor)
                if not edge:
                    continue
                    
                new_dist = dist + get_edge_weight(edge)
                if (neighbor not in distances or 
                    new_dist < distances[neighbor]):
                    distances[neighbor] = new_dist
                    heappush(pq, (new_dist, neighbor))
                    
        return access_nodes
        
    def _compute_transit_distances(self) -> None:
        """Compute distances between all pairs of transit nodes."""
        for source in self.transit_nodes:
            distances = self._dijkstra_from_node(source)
            for target in self.transit_nodes:
                if target in distances:
                    self.distances[(source, target)] = distances[target]
                    
    def _compute_distance_threshold(self, node: str) -> float:
        """Compute locality radius for access node computation."""
        # This could be tuned based on graph properties
        return 100.0  # Example fixed threshold
        
    def query_distance(self, source: str, target: str) -> float:
        """Query distance using transit node routing."""
        # Handle local queries
        if self._is_local_query(source, target):
            return self._compute_local_distance(source, target)
            
        # Get access nodes
        source_access = self.access_nodes[source]
        target_access = self.access_nodes[target]
        
        # Find minimum distance through transit nodes
        min_dist = float('inf')
        for s_access in source_access:
            s_dist = self._compute_local_distance(source, s_access)
            for t_access in target_access:
                transit_dist = self.distances.get((s_access, t_access))
                if transit_dist is not None:
                    t_dist = self._compute_local_distance(t_access, target)
                    min_dist = min(min_dist, s_dist + transit_dist + t_dist)
                    
        if min_dist == float('inf'):
            raise NoPathError(f"No path exists between {source} and {target}")
            
        return min_dist
        
    def _is_local_query(self, source: str, target: str) -> bool:
        """Determine if query should be handled locally."""
        # Simple implementation based on shared access nodes
        return bool(self.access_nodes[source] & self.access_nodes[target])
        
    def _compute_local_distance(self, source: str, target: str) -> float:
        """Compute distance for local queries using Dijkstra."""
        distances = {source: 0.0}
        pq = [(0.0, source)]
        visited = set()
        
        while pq:
            dist, current = heappop(pq)
            
            if current == target:
                return dist
                
            if current in visited:
                continue
                
            visited.add(current)
            
            for neighbor in self.graph.get_neighbors(current):
                edge = self.graph.get_edge(current, neighbor)
                if not edge:
                    continue
                    
                new_dist = dist + get_edge_weight(edge)
                if (neighbor not in distances or 
                    new_dist < distances[neighbor]):
                    distances[neighbor] = new_dist
                    heappush(pq, (new_dist, neighbor))
                    
        raise NoPathError(f"No local path exists between {source} and {target}")
    
    # 5. Hierarchical Multi-Level Routing

This algorithm is particularly useful for graphs with natural hierarchies (like software dependencies, organizational structures, etc.)

```python
from dataclasses import dataclass
from typing import Dict, Set, List, Optional, Tuple
from enum import Enum

class HierarchyLevel(Enum):
    LOW = 0
    MEDIUM = 1
    HIGH = 2

@dataclass
class HierarchyNode:
    node_id: str
    level: HierarchyLevel
    parent: Optional[str]
    children: Set[str]

class HierarchicalRouter:
    def __init__(self, graph: Graph):
        self.graph = graph
        self.hierarchy: Dict[str, HierarchyNode] = {}
        self.level_shortcuts: Dict[HierarchyLevel, Dict[Tuple[str, str], Edge]] = {
            level: {} for level in HierarchyLevel
        }

    def build_hierarchy(self, n_jobs: int = -1) -> None:
        """
        Build hierarchical structure with parallel processing.
        
        Args:
            n_jobs: Number of parallel jobs (-1 for all cores)
        """
        # Determine number of workers
        n_jobs = cpu_count() if n_jobs == -1 else n_jobs
        
        with ThreadPoolExecutor(max_workers=n_jobs) as executor:
            # Phase 1: Detect communities in parallel
            community_futures = [
                executor.submit(self._detect_community, node)
                for node in self.graph.get_nodes()
            ]
            communities = {
                node: future.result()
                for node, future in zip(self.graph.get_nodes(), community_futures)
            }
            
            # Phase 2: Determine hierarchy levels
            level_futures = [
                executor.submit(
                    self._determine_level,
                    node,
                    communities[node]
                )
                for node in self.graph.get_nodes()
            ]
            levels = {
                node: future.result()
                for node, future in zip(self.graph.get_nodes(), level_futures)
            }
            
            # Phase 3: Build shortcuts for each level
            shortcut_futures = []
            for level in HierarchyLevel:
                nodes_at_level = {
                    node for node, node_level in levels.items()
                    if node_level == level
                }
                shortcut_futures.extend([
                    executor.submit(
                        self._build_shortcuts_for_node,
                        node,
                        nodes_at_level
                    )
                    for node in nodes_at_level
                ])
                
            # Collect shortcuts
            for future in as_completed(shortcut_futures):
                source, shortcuts = future.result()
                if shortcuts:
                    self.level_shortcuts[source] = shortcuts
                    
        # Final validation
        self._validate_hierarchy()


    def _detect_communities(self) -> Dict[str, Set[str]]:
        """Detect communities in the graph using Louvain method."""
        # Simplified community detection
        communities: Dict[str, Set[str]] = {}
        visited = set()
        
        for node in self.graph.get_nodes():
            if node in visited:
                continue
                
            # Find connected component as a simple community
            community = set()
            queue = [node]
            
            while queue:
                current = queue.pop(0)
                if current in visited:
                    continue
                    
                visited.add(current)
                community.add(current)
                
                for neighbor in self.graph.get_neighbors(current):
                    if neighbor not in visited:
                        queue.append(neighbor)
                        
            if community:
                communities[node] = community
                
        return communities
        
    def _determine_level(self, node: str, community: Set[str]) -> HierarchyLevel:
        """Determine hierarchy level of a node."""
        # Calculate node importance
        degree = len(list(self.graph.get_neighbors(node)))
        community_centrality = self._calculate_community_centrality(node, community)
        
        if community_centrality > 0.8 and degree > len(community) / 2:
            return HierarchyLevel.HIGH
        elif community_centrality > 0.5 and degree > len(community) / 4:
            return HierarchyLevel.MEDIUM
        else:
            return HierarchyLevel.LOW
            
    def _build_shortcuts(self) -> None:
        """Build shortcuts between nodes at each hierarchy level."""
        for level in HierarchyLevel:
            nodes_at_level = {
                node_id for node_id, node in self.hierarchy.items()
                if node.level == level
            }
            
            for source in nodes_at_level:
                paths = self._find_important_paths(source, nodes_at_level)
                for target, path in paths.items():
                    if path:
                        shortcut = self._create_shortcut(path)
                        self.level_shortcuts[level][(source, target)] = shortcut
                        
    def find_hierarchical_path(
        self,
        start: str,
        end: str,
        weight_func = None
    ) -> PathResult:
        """Find path using hierarchical routing."""
        if start not in self.hierarchy or end not in self.hierarchy:
            raise NoPathError("Nodes not in hierarchy")
            
        start_level = self.hierarchy[start].level
        end_level = self.hierarchy[end].level
        
        # Find highest common level
        common_level = min(start_level, end_level)
        
        # Climb up hierarchy from start
        up_path = self._climb_hierarchy(start, common_level)
        
        # Find path at common level
        level_path = self._find_level_path(
            up_path[-1] if up_path else start,
            end if end_level == common_level else self.hierarchy[end].parent,
            common_level
        )
        
        # Climb down hierarchy to end
        down_path = self._climb_hierarchy(end, common_level, ascending=False)
        
        # Combine paths
        complete_path = up_path + level_path + list(reversed(down_path))
        return create_path_result(complete_path, weight_func)
        
    def _climb_hierarchy(
        self,
        node: str,
        target_level: HierarchyLevel,
        ascending: bool = True
    ) -> List[Edge]:
        """Climb hierarchy up or down to target level."""
        path = []
        current = node
        
        while self.hierarchy[current].level != target_level:
            next_node = (self.hierarchy[current].parent if ascending
                        else next(iter(self.hierarchy[current].children)))
            edge = self.graph.get_edge(
                current if ascending else next_node,
                next_node if ascending else current
            )
            if edge:
                path.append(edge)
            current = next_node
            
        return path
        
    def _find_level_path(
        self,
        start: str,
        end: str,
        level: HierarchyLevel
    ) -> List[Edge]:
        """Find path between nodes at the same hierarchy level."""
        # Use shortcuts if available
        if (start, end) in self.level_shortcuts[level]:
            return [self.level_shortcuts[level][(start, end)]]
            
        # Fall back to regular pathfinding
        return self._find_path_in_level(start, end, level)
```

The Hierarchical Multi-Level Routing algorithm is particularly effective for:
1. Graphs with natural hierarchies
2. Reducing search space in large graphs
3. Finding paths that respect organizational/structural boundaries

Key advantages:
1. Faster queries for hierarchical structures
2. More natural paths through the hierarchy
3. Better handling of domain-specific constraints

Would you like me to:
1. Add more specialized algorithms
2. Detail the complexity analysis for these implementations 
3. Add specific optimizations for your use case
4. Show how to integrate these with the existing codebase?# Advanced Graph Algorithm Implementations

## 1. Contraction Hierarchies

Contraction Hierarchies provide massive speedup for shortest path queries by preprocessing the graph.

```python
from dataclasses import dataclass
from typing import Dict, Set, List, Tuple, Optional
from heapq import heappush, heappop

@dataclass(frozen=True)
class Shortcut:
    edge: Edge
    via_node: str
    lower_edge: Edge
    upper_edge: Edge

class ContractionHierarchies:
    def __init__(self, graph: Graph):
        self.graph = graph
        self.node_level: Dict[str, int] = {}
        self.shortcuts: Dict[Tuple[str, str], Shortcut] = {}
        self.contracted_neighbors: Dict[str, Set[str]] = defaultdict(set)
        
    def preprocess(self) -> None:
        """Preprocess graph to build contraction hierarchy."""
        # Calculate initial node ordering
        node_importance = self._calculate_node_importance()
        pq = [(importance, node) for node, importance in node_importance.items()]
        heapq.heapify(pq)
        
        level = 0
        while pq:
            _, node = heappop(pq)
            if node not in self.node_level:  # Not yet contracted
                # Contract node
                shortcuts = self._contract_node(node)
                self.node_level[node] = level
                level += 1
                
                # Update importance of affected nodes
                affected = set()
                for u, v in shortcuts:
                    affected.add(u)
                    affected.add(v)
                    
                for affected_node in affected:
                    if affected_node not in self.node_level:
                        new_importance = self._calculate_node_importance(affected_node)
                        heappush(pq, (new_importance, affected_node))
                        
    def _contract_node(self, node: str) -> List[Tuple[str, str]]:
        """Contract a node and add necessary shortcuts."""
        shortcuts = []
        incoming = self.graph.get_neighbors(node, reverse=True)
        outgoing = self.graph.get_neighbors(node)
        
        for u in incoming:
            if u in self.node_level:  # Skip already contracted nodes
                continue
                
            for v in outgoing:
                if v in self.node_level or u == v:
                    continue
                    
                # Check if shortcut is necessary
                lower_edge = self.graph.get_edge(u, node)
                upper_edge = self.graph.get_edge(node, v)
                if not lower_edge or not upper_edge:
                    continue
                    
                shortcut_weight = (get_edge_weight(lower_edge) + 
                                 get_edge_weight(upper_edge))
                                 
                # Check if shortcut is necessary (witness search)
                if self._is_shortcut_necessary(u, v, node, shortcut_weight):
                    shortcut_edge = Edge(
                        from_entity=u,
                        to_entity=v,
                        relation_type=RelationType.SHORTCUT,
                        metadata=EdgeMetadata(
                            weight=shortcut_weight,
                            via_node=node
                        )
                    )
                    
                    self.shortcuts[(u, v)] = Shortcut(
                        edge=shortcut_edge,
                        via_node=node,
                        lower_edge=lower_edge,
                        upper_edge=upper_edge
                    )
                    
                    shortcuts.append((u, v))
                    self.contracted_neighbors[u].add(v)
                    
        return shortcuts
        
    def _is_shortcut_necessary(
        self, 
        u: str, 
        v: str, 
        via: str, 
        shortcut_weight: float
    ) -> bool:
        """Determine if shortcut is necessary using witness search."""
        MAX_WITNESS_SEARCH_STEPS = 50  # Limit witness search
        
        distances = {u: 0.0}
        pq = [(0.0, u)]
        visited = set()
        steps = 0
        
        while pq and steps < MAX_WITNESS_SEARCH_STEPS:
            dist, node = heappop(pq)
            
            if node == v:
                return dist >= shortcut_weight
                
            if node in visited:
                continue
                
            visited.add(node)
            steps += 1
            
            for neighbor in self.graph.get_neighbors(node):
                if neighbor == via:  # Don't go through the node being contracted
                    continue
                    
                edge = self.graph.get_edge(node, neighbor)
                if not edge:
                    continue
                    
                new_dist = dist + get_edge_weight(edge)
                if new_dist < shortcut_weight:  # Early termination
                    if neighbor not in distances or new_dist < distances[neighbor]:
                        distances[neighbor] = new_dist
                        heappush(pq, (new_dist, neighbor))
                        
        return True  # No witness path found
        
    def _calculate_node_importance(self, node: str) -> float:
        """Calculate importance of a node for contraction ordering."""
        edge_difference = self._count_shortcuts(node) - len(list(self.graph.get_neighbors(node)))
        contracted_neighbors = len(self.contracted_neighbors[node])
        level = self.node_level.get(node, 0)
        
        # Combine factors with appropriate weights
        return (
            5 * edge_difference +
            3 * contracted_neighbors +
            2 * level
        )
        
    def _count_shortcuts(self, node: str) -> int:
        """Count number of shortcuts needed when contracting node."""
        shortcuts = set()
        incoming = self.graph.get_neighbors(node, reverse=True)
        outgoing = self.graph.get_neighbors(node)
        
        for u in incoming:
            if u in self.node_level:
                continue
            for v in outgoing:
                if v in self.node_level or u == v:
                    continue
                shortcuts.add((u, v))
                
        return len(shortcuts)

```

## 2. A* with Landmarks (ALT Algorithm)

The ALT algorithm uses triangle inequality with precomputed landmarks to provide better heuristics for A* search.

```python
from typing import Dict, Set, List, Optional
import numpy as np

class ALTPathFinder:
    def __init__(self, graph: Graph, num_landmarks: int = 16):
        self.graph = graph
        self.landmarks: List[str] = self._select_landmarks(num_landmarks)
        self.distances: Dict[str, Dict[str, float]] = {}
        self._precompute_distances()
        
    def _select_landmarks(self, num_landmarks: int) -> List[str]:
        """Select landmarks using maximal separation method."""
        nodes = list(self.graph.get_nodes())
        if len(nodes) <= num_landmarks:
            return nodes
            
        landmarks = []
        # Start with a random node
        landmarks.append(random.choice(nodes))
        
        while len(landmarks) < num_landmarks:
            max_distance = -1
            next_landmark = None
            
            # For each node, compute minimum distance to existing landmarks
            for node in nodes:
                if node in landmarks:
                    continue
                    
                min_dist = float('inf')
                for landmark in landmarks:
                    dist = self._compute_distance(node, landmark)
                    min_dist = min(min_dist, dist)
                    
                if min_dist > max_distance:
                    max_distance = min_dist
                    next_landmark = node
                    
            if next_landmark:
                landmarks.append(next_landmark)
                
        return landmarks
        
    def _precompute_distances(self) -> None:
        """Precompute distances from all nodes to landmarks."""
        for landmark in self.landmarks:
            # Forward distances
            forward_distances = self._dijkstra_from_landmark(landmark)
            self.distances[landmark] = forward_distances
            
            # Backward distances
            backward_distances = self._dijkstra_to_landmark(landmark)
            self.distances[f"r_{landmark}"] = backward_distances
            
    def _compute_heuristic(self, node: str, target: str) -> float:
        """Compute ALT heuristic using landmarks."""
        h = 0.0
        for landmark in self.landmarks:
            # Forward heuristic
            if (landmark in self.distances and 
                node in self.distances[landmark] and 
                target in self.distances[landmark]):
                h = max(h, abs(
                    self.distances[landmark][target] - 
                    self.distances[landmark][node]
                ))
            
            # Backward heuristic
            r_landmark = f"r_{landmark}"
            if (r_landmark in self.distances and 
                node in self.distances[r_landmark] and 
                target in self.distances[r_landmark]):
                h = max(h, abs(
                    self.distances[r_landmark][node] - 
                    self.distances[r_landmark][target]
                ))
                
        return h
        
    def find_path(
        self,
        start: str,
        end: str,
        weight_func = None
    ) -> PathResult:
        """Find shortest path using A* with ALT heuristic."""
        pq = [(0.0, 0.0, start)]  # (f_score, g_score, node)
        g_scores = {start: 0.0}
        came_from = {}
        
        while pq:
            f_score, g_score, current = heappop(pq)
            
            if current == end:
                return self._reconstruct_path(came_from, end)
                
            for neighbor in self.graph.get_neighbors(current):
                edge = self.graph.get_edge(current, neighbor)
                if not edge:
                    continue
                    
                tentative_g = g_score + get_edge_weight(edge, weight_func)
                
                if (neighbor not in g_scores or 
                    tentative_g < g_scores[neighbor]):
                    came_from[neighbor] = (current, edge)
                    g_scores[neighbor] = tentative_g
                    h_score = self._compute_heuristic(neighbor, end)
                    f_score = tentative_g + h_score
                    heappush(pq, (f_score, tentative_g, neighbor))
                    
        raise NoPathError(f"No path exists between {start} and {end}")
```

## 3. Hub Labeling

Hub Labeling provides extremely fast distance queries at the cost of higher preprocessing time and space.

```python
from typing import Dict, Set, List, Tuple
import numpy as np

class HubLabels:
    def __init__(self, graph: Graph):
        self.graph = graph
        self.forward_labels: Dict[str, List[Tuple[str, float]]] = {}
        self.backward_labels: Dict[str, List[Tuple[str, float]]] = {}
        
    def preprocess(self) -> None:
        """Preprocess graph to compute hub labels."""
        # Compute node ordering (can use various strategies)
        node_order = self._compute_node_order()
        
        # Process nodes in order
        for node in node_order:
            # Compute forward labels
            self._compute_forward_labels(node)
            # Compute backward labels
            self._compute_backward_labels(node)
            
    def _compute_forward_labels(self, node: str) -> None:
        """Compute forward labels for a node using pruned Dijkstra."""
        distances = {node: 0.0}
        pq = [(0.0, node)]
        
        while pq:
            dist, current = heappop(pq)
            
            # Pruning condition
            if self._should_prune_forward(node, current, dist):
                continue
                
            # Add label
            if node not in self.forward_labels:
                self.forward_labels[node] = []
            self.forward_labels[node].append((current, dist))
            
            # Explore neighbors
            for neighbor in self.graph.get_neighbors(current):
                edge = self.graph.get_edge(current, neighbor)
                if not edge:
                    continue
                    
                new_dist = dist + get_edge_weight(edge)
                if (neighbor not in distances or 
                    new_dist < distances[neighbor]):
                    distances[neighbor] = new_dist
                    heappush(pq, (new_dist, neighbor))
                    
    def _should_prune_forward(
        self,
        source: str,
        current: str,
        distance: float
    ) -> bool:
        """Check if forward search can be pruned."""
        if current not in self.forward_labels:
            return False
            
        # Check if distance can be computed using existing labels
        min_dist = float('inf')
        for hub, hub_dist in self.forward_labels[source]:
            if hub in self.backward_labels:
                for target, target_dist in self.backward_labels[hub]:
                    if target == current:
                        min_dist = min(min_dist, hub_dist + target_dist)
                        
        return distance >= min_dist
        
    def query_distance(self, source: str, target: str) -> float:
        """Query shortest path distance using hub labels."""
        if source not in self.forward_labels or target not in self.backward_labels:
            raise NoPathError(f"No path exists between {source} and {target}")
            
        min_dist = float('inf')
        for hub, forward_dist in self.forward_labels[source]:
            if hub in self.backward_labels[target]:
                backward_dist = next(
                    d for h, d in self.backward_labels[target] if h == hub
                )
                min_dist = min(min_dist, forward_dist + backward_dist)
                
        if min_dist == float('inf'):
            raise NoPathError(f"No path exists between {source} and {target}")
            
        return min_dist
```

## 4. Transit Node Routing

Specialized for road networks, Transit Node Routing provides extremely fast queries for long-distance routes.

```python
from typing import Dict, Set, List, Tuple
import numpy as np

class TransitNodeRouting:
    def __init__(self, graph: Graph):
        self.graph = graph
        self.transit_nodes: Set[str] = set()
        self.access_nodes: Dict[str, Set[str]] = {}
        self.distances: Dict[Tuple[str, str], float] = {}
        
    def preprocess(self, num_transit_nodes: int = 1000) -> None:
        """Preprocess graph to identify transit nodes and compute distances."""
        # Select transit nodes (could use various strategies)
        self.transit_nodes = self._select_transit_nodes(num_transit_nodes)
        
        # Compute access nodes for each vertex
        for node in self.graph.get_nodes():
            self.access_nodes[node] = self._compute_access_nodes(node)
            
        # Compute distances between transit nodes
        self._compute_transit_distances()
        
    def _select_transit_nodes(self, num_nodes: int) -> Set[str]:
        """Select transit nodes using degree centrality."""
        nodes = [(node, len(list(self.graph.get_neighbors(node))))
                for node in self.graph.get_nodes()]
        nodes.sort(key=lambda x: x[1], reverse=True)
        return set(node for node, _ in nodes[:num_nodes])
        
    def _compute_access_nodes(self, node: str) -> Set[str]:
        """Compute access nodes for a given vertex."""
        access_nodes = set()
        distance_threshold = self._compute_distance_threshold(node)
        
        # Run Dijkstra until threshold
        distances = {node: 0.0}
        pq = [(0.0, node)]
        
        while pq:
            dist, current = heappop(pq)
            
            if dist > distance_threshold:
                break
                
            if current in self.transit_nodes:
                access_nodes.add(current)
                continue
                
            for neighbor in self.graph.get_neighbors(current):
                edge = self.graph.get_edge(current, neighbor)
                if not edge:
                    continue
                    
                new_dist = dist + get_edge_weight(edge)
                if (neighbor not in distances or 
                    new_dist < distances[neighbor]):
                    distances[neighbor] = new_dist
                    heappush(pq, (new_dist, neighbor))
                    
        return access_nodes
        
    def _compute_transit_distances(self) -> None:
        """Compute distances between all pairs of transit nodes."""
        for source in self.transit_nodes:
            distances = self._dijkstra_from_node(source)
            for target in self.transit_nodes:
                if target in distances:
                    self.distances[(source, target)] = distances[target]
                    
    def _compute_distance_threshold(self, node: str) -> float:
        """Compute locality radius for access node computation."""
        # This could be tuned based on graph properties
        return 100.0  # Example fixed threshold
        
    def query_distance(self, source: str, target: str) -> float:
        """Query distance using transit node routing."""
        # Handle local queries
        if self._is_local_query(source, target):
            return self._compute_local_distance(source, target)
            
        # Get access nodes
        source_access = self.access_nodes[source]
        target_access = self.access_nodes[target]
        
        # Find minimum distance through transit nodes
        min_dist = float('inf')
        for s_access in source_access:
            s_dist = self._compute_local_distance(source, s_access)
            for t_access in target_access:
                transit_dist = self.distances.get((s_access, t_access))
                if transit_dist is not None:
                    t_dist = self._compute_local_distance(t_access, target)
                    min_dist = min(min_dist, s_dist + transit_dist + t_dist)
                    
        if min_dist == float('inf'):
            raise NoPathError(f"No path exists between {source} and {target}")
            
        return min_dist
        
    def _is_local_query(self, source: str, target: str) -> bool:
        """Determine if query should be handled locally."""
        # Simple implementation based on shared access nodes
        return bool(self.access_nodes[source] & self.access_nodes[target])
        
    def _compute_local_distance(self, source: str, target: str) -> float:
        """Compute distance for local queries using Dijkstra."""
        distances = {source: 0.0}
        pq = [(0.0, source)]
        visited = set()
        
        while pq:
            dist, current = heappop(pq)
            
            if current == target:
                return dist
                
            if current in visited:
                continue
                
            visited.add(current)
            
            for neighbor in self.graph.get_neighbors(current):
                edge = self.graph.get_edge(current, neighbor)
                if not edge:
                    continue
                    
                new_dist = dist + get_edge_weight(edge)
                if (neighbor not in distances or 
                    new_dist < distances[neighbor]):
                    distances[neighbor] = new_dist
                    heappush(pq, (new_dist, neighbor))
                    
        raise NoPathError(f"No local path exists between {source} and {target}")
    

    Consider these utilities if required:
    # Graph Utility Functions

Create a new file `src/core/graph_paths/utils.py` or add to existing:

```python
import os
import psutil
import resource
from typing import Dict, List, Optional, Set, Tuple, Callable
from dataclasses import dataclass
from .models import Edge, PathResult
from ..exceptions import (
    MemoryLimitExceeded,
    NegativeWeightError,
    ValidationError,
    NoPathError
)

def get_memory_usage() -> int:
    """
    Get current memory usage in bytes.
    Uses multiple methods for cross-platform support.
    
    Returns:
        Current memory usage in bytes
    """
    try:
        # Try psutil first (most accurate, cross-platform)
        process = psutil.Process(os.getpid())
        return process.memory_info().rss
    except (ImportError, AttributeError):
        try:
            # Fallback to resource module on Unix
            return resource.getrusage(resource.RUSAGE_SELF).ru_maxrss * 1024
        except (ImportError, AttributeError):
            # Basic fallback if no other method works
            import gc
            gc.collect()  # Force collection to get accurate reading
            return sum(sys.getsizeof(obj) for obj in gc.get_objects())

def validate_path_consistency(
    path: List[Edge],
    graph: 'Graph',
    weight_func: Optional[Callable[[Edge], float]] = None
) -> None:
    """
    Validate path consistency with comprehensive checks.
    
    Args:
        path: List of edges forming the path
        graph: Graph instance for validation
        weight_func: Optional custom weight function
        
    Raises:
        ValidationError: If any validation check fails
    """
    if not path:
        return
        
    # Check node connectivity
    for i in range(len(path) - 1):
        if path[i].to_entity != path[i + 1].from_entity:
            raise ValidationError(
                f"Path discontinuity between edges {i} and {i+1}: "
                f"{path[i].to_entity} != {path[i + 1].from_entity}"
            )
            
    # Verify edges exist in graph
    for edge in path:
        if not graph.has_edge(edge.from_entity, edge.to_entity):
            raise ValidationError(
                f"Edge from {edge.from_entity} to {edge.to_entity} "
                "not found in graph"
            )
            
    # Check for self-loops if not allowed
    if not graph.allow_self_loops:
        for edge in path:
            if edge.from_entity == edge.to_entity:
                raise ValidationError(
                    f"Self-loop detected at node {edge.from_entity}"
                )
                
def get_path_properties(
    path: List[Edge],
    weight_func: Optional[Callable[[Edge], float]] = None
) -> Tuple[float, Set[str]]:
    """
    Calculate path properties efficiently.
    
    Args:
        path: List of edges in path
        weight_func: Optional custom weight function
        
    Returns:
        Tuple of (total_weight, unique_nodes)
    """
    total_weight = 0.0
    unique_nodes = set()
    
    for edge in path:
        unique_nodes.add(edge.from_entity)
        unique_nodes.add(edge.to_entity)
        total_weight += weight_func(edge) if weight_func else edge.weight
        
    return total_weight, unique_nodes

@dataclass
class PathMetrics:
    """Container for path analysis metrics."""
    length: int
    total_weight: float
    unique_nodes: int
    has_cycles: bool
    max_edge_weight: float
    min_edge_weight: float
    
    @classmethod
    def from_path(
        cls,
        path: List[Edge],
        weight_func: Optional[Callable[[Edge], float]] = None
    ) -> 'PathMetrics':
        """Create metrics from path."""
        if not path:
            return cls(0, 0.0, 0, False, 0.0, 0.0)
            
        weights = [weight_func(e) if weight_func else e.weight for e in path]
        nodes = set()
        for edge in path:
            nodes.add(edge.from_entity)
            nodes.add(edge.to_entity)
            
        return cls(
            length=len(path),
            total_weight=sum(weights),
            unique_nodes=len(nodes),
            has_cycles=len(nodes) < len(path) + 1,
            max_edge_weight=max(weights),
            min_edge_weight=min(weights)
        )

class GraphMemoryManager:
    """Memory management utilities for graph algorithms."""
    
    def __init__(self, max_memory_mb: Optional[int] = None):
        self.max_memory = max_memory_mb * 1024 * 1024 if max_memory_mb else None
        self.start_memory = get_memory_usage()
        
    def check_memory(self) -> None:
        """Check if memory usage exceeds limit."""
        if not self.max_memory:
            return
            
        current = get_memory_usage()
        if current - self.start_memory > self.max_memory:
            raise MemoryLimitExceeded(
                f"Memory usage {current/1024/1024:.1f}MB exceeds "
                f"limit of {self.max_memory/1024/1024:.1f}MB"
            )
            
    @contextmanager
    def monitor_allocation(self, label: str = "") -> None:
        """Context manager to monitor memory allocation."""
        start = get_memory_usage()
        yield
        end = get_memory_usage()
        allocated = end - start
        if allocated > 1024 * 1024:  # Log if over 1MB
            logger.debug(
                f"Memory allocated for {label}: "
                f"{allocated/1024/1024:.1f}MB"
            )

def estimate_path_memory(path: List[Edge]) -> int:
    """Estimate memory usage of path in bytes."""
    base_size = 24  # List overhead
    edge_size = 64  # Approximate Edge object size
    return base_size + (edge_size * len(path))

# Priority Queue with Decrease Key
class PriorityQueue:
    """Priority queue with decrease-key operation."""
    
    def __init__(self):
        self._queue: List[Tuple[float, int, str]] = []
        self._entry_finder: Dict[str, Tuple[float, int]] = {}
        self._counter = 0
        
    def add_or_update(self, item: str, priority: float) -> None:
        """Add new item or update existing item's priority."""
        if item in self._entry_finder:
            self._entry_finder[item] = (float('inf'), self._counter)
        entry = (priority, self._counter, item)
        self._entry_finder[item] = (priority, self._counter)
        self._counter += 1
        heappush(self._queue, entry)
        
    def pop(self) -> Optional[Tuple[float, str]]:
        """Remove and return lowest priority item."""
        while self._queue:
            priority, count, item = heappop(self._queue)
            stored_priority, stored_count = self._entry_finder.get(
                item, (None, None)
            )
            if stored_priority == priority and stored_count == count:
                del self._entry_finder[item]
                return (priority, item)
        return None
        
    def empty(self) -> bool:
        """Return True if queue is empty."""
        return len(self._entry_finder) == 0

# Validation Functions
def validate_graph(graph: 'Graph') -> None:
    """Validate graph integrity."""
    # Check node consistency
    for node in graph.get_nodes():
        for neighbor in graph.get_neighbors(node):
            if not graph.has_edge(node, neighbor):
                raise ValidationError(
                    f"Inconsistent edge: {node} -> {neighbor}"
                )
                
    # Check edge consistency
    for edge in graph.get_edges():
        if not graph.has_node(edge.from_entity):
            raise ValidationError(
                f"Edge references missing node: {edge.from_entity}"
            )
        if not graph.has_node(edge.to_entity):
            raise ValidationError(
                f"Edge references missing node: {edge.to_entity}"
            )
            
def validate_weight_function(
    weight_func: Callable[[Edge], float],
    sample_edges: List[Edge]
) -> None:
    """Validate weight function behavior."""
    for edge in sample_edges:
        try:
            weight = weight_func(edge)
            if not isinstance(weight, (int, float)):
                raise ValidationError(
                    f"Weight function returned non-numeric value: {weight}"
                )
            if math.isnan(weight) or math.isinf(weight):
                raise ValidationError(
                    f"Weight function returned invalid value: {weight}"
                )
        except Exception as e:
            raise ValidationError(
                f"Weight function failed on edge {edge}: {str(e)}"
            )

class Timer:
    """Context manager for timing operations."""
    
    def __init__(self, label: str = ""):
        self.label = label
        self.start_time = 0
        
    def __enter__(self):
        self.start_time = time.perf_counter()
        return self
        
    def __exit__(self, *args):
        duration = time.perf_counter() - self.start_time
        if self.label:
            logger.debug(f"{self.label}: {duration*1000:.1f}ms")
```

These utility functions provide:
1. Memory management and monitoring
2. Path validation and analysis
3. Efficient priority queue implementation
4. Graph validation utilities
5. Performance monitoring tools

Would you like me to:
1. Add more utility functions for specific use cases
2. Add more detailed documentation
3. Create unit tests for these utilities
4. Add more error handling cases

Or we can move on to implementing other parts of the system.